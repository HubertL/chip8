// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  var Chip8Assembler;

  Chip8Assembler = function() {
    var BYTE, BYTE3, LABEL, REGISTER, WORD, assemble, expectNewline, getLabels, instructionTypes, parse, parseInstruction, partValidators, raise, setupInstructions, setupPartValidators;
    LABEL = 'label';
    REGISTER = 'register';
    WORD = 'word';
    BYTE = 'byte';
    BYTE3 = 'byte3';
    raise = function(message, coords) {
      var error;
      error = Error(message);
      error.coords = coords;
      throw error;
    };
    setupPartValidators = function() {
      var registerRegex, ret;
      ret = {};
      ret[LABEL] = function(token, labels) {
        if (token.type !== 'identifier') {
          raise("Expected a label", token.coords);
        }
        if (!labels.has(token.value)) {
          return raise("Label " + token.value + " has not been declared", token.coords);
        }
      };
      registerRegex = /^v[0-9A-F]$/;
      ret[REGISTER] = function(token) {
        if (!(token.type === 'identifier' && registerRegex.test(token.value))) {
          return raise("Expected a register", token.coords);
        }
      };
      ret[WORD] = function(token) {
        if (!(token.type === 'number' && +token.value < 256 * 256)) {
          return raise("Expected a word", token.coords);
        }
      };
      ret[BYTE] = function(token) {
        if (!(token.type === 'number' && +token.value < 256)) {
          return raise("Expected a byte", token.coords);
        }
      };
      ret[BYTE3] = function(token) {
        if (!(token.type === 'number' && +token.value < 8)) {
          return raise("Expected a number between 0 and 7", token.coords);
        }
      };
      return ret;
    };
    setupInstructions = function() {
      var add, add_NNN, add_XNN, add_XY_, add_X__, ret;
      ret = new Map();
      add = function(name, expectedParts, encoder) {
        return ret.set(name, {
          expectedParts: expectedParts,
          encoder: encoder
        });
      };
      add_NNN = function(name, code0) {
        return add(name, [LABEL], function(parts, labels) {
          return code0 | (labels.get(parts[1].value));
        });
      };
      add_XNN = function(name, code0) {
        return add(name, [REGISTER, BYTE], function(parts) {
          return code0 | ((parseInt(parts[1].value[1], 16)) << 8) | (parseInt(parts[2].value, 10));
        });
      };
      add_XY_ = function(name, code0, code3) {
        return add(name, [REGISTER, REGISTER], function(parts) {
          return code1 | ((parseInt(parts[1].value[1], 16)) << 8) | ((parseInt(parts[2].value[1], 16)) << 4) | code3;
        });
      };
      add_X__ = function(name, code0, code23) {
        return add(name, [REGISTER], function(parts) {
          return code0 | ((parseInt(parts[1].value[1], 16)) << 8) | code23;
        });
      };
      add('cls', [], function() {
        return 0x00E0;
      });
      add('return', [], function() {
        return 0x00EE;
      });
      add_NNN('jump', 0x1000);
      add_NNN('call', 0x2000);
      add_XNN('sei', 0x3000);
      add_XNN('snei', 0x4000);
      add_XY_('ser', 0x5000, 0x0000);
      add_XNN('movi', 0x6000);
      add_XNN('addi', 0x7000);
      add_XY_('movr', 0x8000, 0x0000);
      add_XY_('or', 0x8000, 0x0001);
      add_XY_('and', 0x8000, 0x0002);
      add_XY_('xor', 0x8000, 0x0003);
      add_XY_('addr', 0x8000, 0x0004);
      add_XY_('subr', 0x8000, 0x0005);
      add_XY_('shr', 0x8000, 0x0006);
      add_XY_('nsubr', 0x8000, 0x0007);
      add_XY_('shl', 0x8000, 0x000E);
      add_XY_('sner', 0x9000, 0x0000);
      add_NNN('imovi', 0xA000);
      add_NNN('jumpoff', 0xB000);
      add_XNN('rnd', 0xC000);
      add('sprite', [REGISTER, REGISTER, BYTE3], function(parts) {
        return 0xD000 | ((parseInt(parts[1].value[1], 16)) << 8) | ((parseInt(parts[2].value[1], 16)) << 4) | (parseInt(parts[3].value));
      });
      add_X__('skr', 0xE000, 0x009E);
      add_X__('snkr', 0xE000, 0x00A1);
      add_X__('rmovt', 0xF000, 0x0007);
      add_X__('waitk', 0xF000, 0x000A);
      add_X__('movt', 0xF000, 0x0015);
      add_X__('movs', 0xF000, 0x0018);
      add_X__('iaddr', 0xF000, 0x001E);
      add_X__('digit', 0xF000, 0x0029);
      add_X__('bcd', 0xF000, 0x0033);
      add_X__('store', 0xF000, 0x0055);
      add_X__('load', 0xF000, 0x0065);
      add('dw', [WORD], function(parts) {
        return parts[1].value;
      });
      return ret;
    };
    instructionTypes = setupInstructions();
    partValidators = setupPartValidators();
    parseInstruction = function(tokens, labels) {
      var expectedParts, fullInstruction, instruction, instructionType, token;
      token = tokens.getCurrent();
      tokens.setMarker();
      instruction = token.value;
      if (!instructionTypes.has(instruction)) {
        raise("Unrecognised instruction " + instruction + " in line " + token.coords.line, token.coords);
      }
      instructionType = instructionTypes.get(instruction);
      tokens.advance();
      expectedParts = instructionType.expectedParts;
      expectedParts.forEach(function(expectedPart, index) {
        var partValidator;
        partValidator = partValidators[expectedParts[index]];
        partValidator(tokens.getCurrent(), labels);
        tokens.advance();
      });
      fullInstruction = instructionType.encoder(tokens.getMarked(), labels);
      return [fullInstruction >> 8, fullInstruction & 0x00FF];
    };
    expectNewline = function(tokens, message) {
      if (tokens.getCurrent().type !== 'end') {
        return tokens.expect('newline', message);
      }
    };
    getLabels = function(tokens) {
      var addressCounter, labels, token;
      labels = new Map();
      addressCounter = 0x200;
      while (tokens.hasNext()) {
        token = tokens.getCurrent();
        if (token.type === 'label') {
          if (labels.has(token.value)) {
            raise("label '" + token.value + "' already declared", token.coords);
          }
          labels.set(token.value, addressCounter);
          tokens.advance();
          expectNewline(tokens, 'Expected new line after label declaration');
        } else if (token.type === 'identifier') {
          while (tokens.hasNext() && tokens.getCurrent().type !== 'newline') {
            tokens.advance();
          }
          addressCounter += 2;
        } else if (token.type === 'end') {
          break;
        } else {
          tokens.advance();
        }
      }
      tokens.reset();
      return labels;
    };
    parse = function(rawTokens) {
      var instructions, labels, token, tokens;
      tokens = tokenList(rawTokens);
      labels = getLabels(tokens);
      instructions = [];
      while (tokens.hasNext()) {
        token = tokens.getCurrent();
        if (token.type === 'identifier') {
          Array.prototype.push.apply(instructions, parseInstruction(tokens, labels));
          expectNewline(tokens, 'Expected new line after label declaration');
        } else if (token.type === 'end') {
          break;
        } else if (token.type !== 'newline' && token.type !== 'label') {
          raise("Unexpected " + token.type, token.coords);
        } else {
          tokens.advance();
        }
      }
      return instructions;
    };
    assemble = function(string) {
      var rawTokens;
      rawTokens = Chip8Tokenizer(string);
      return parse(rawTokens);
    };
    return {
      assemble: assemble,
      _getLabels: getLabels
    };
  };

  window.Chip8Assembler = Chip8Assembler;

}).call(this);
