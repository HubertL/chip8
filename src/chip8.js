// Generated by CoffeeScript 1.8.0
(function() {
  'use strict';
  var Chip8;

  Chip8 = function() {
    var HEIGHT, I, START_PROGRAM, V, WIDTH, clearScreen, delayTimer, getI, getProgramCounter, getRegisters, getStack, getStackPointer, getVideo, initChars, keyboard, load, memory, programCounter, reset, setKeyboard, setPixel, soundTimer, stack, stackPointer, tick, video, waitingForKey;
    WIDTH = 64;
    HEIGHT = 32;
    START_PROGRAM = 0x0200;
    video = new Uint8Array(WIDTH * HEIGHT);
    memory = new Uint8Array(0x1000);
    V = new Uint8Array(16);
    stack = new Uint16Array(16);
    soundTimer = 0;
    delayTimer = 0;
    programCounter = START_PROGRAM;
    I = 0;
    stackPointer = 0;
    waitingForKey = false;
    initChars = function() {
      memory.set([0xF0, 0x90, 0x90, 0x90, 0xF0, 0x20, 0x60, 0x20, 0x20, 0x70, 0xF0, 0x10, 0xF0, 0x80, 0xF0, 0xF0, 0x10, 0xF0, 0x10, 0xF0, 0x90, 0x90, 0xF0, 0x10, 0x10, 0xF0, 0x80, 0xF0, 0x10, 0xF0, 0xF0, 0x80, 0xF0, 0x90, 0xF0, 0xF0, 0x10, 0x20, 0x40, 0x40, 0xF0, 0x90, 0xF0, 0x90, 0xF0, 0xF0, 0x90, 0xF0, 0x10, 0xF0, 0xF0, 0x90, 0xF0, 0x90, 0x90, 0xE0, 0x90, 0xE0, 0x90, 0xE0, 0xF0, 0x80, 0x80, 0x80, 0xF0, 0xE0, 0x90, 0x90, 0x90, 0xE0, 0xF0, 0x80, 0xF0, 0x80, 0xF0, 0xF0, 0x80, 0xF0, 0x80, 0x80]);
    };
    load = function(romData) {
      memory.set(romData, START_PROGRAM);
      initChars();
    };
    reset = function() {
      video.fill(0);
      V.fill(0);
      stack.fill(0);
      soundTimer = 0;
      delayTimer = 0;
      programCounter = START_PROGRAM;
      I = 0;
      stackPointer = 0;
      waitingForKey = false;
    };
    getVideo = function() {
      return video;
    };
    getRegisters = function() {
      return V;
    };
    getProgramCounter = function() {
      return programCounter;
    };
    getStackPointer = function() {
      return stackPointer;
    };
    getStack = function() {
      return stack;
    };
    getI = function() {
      return I;
    };
    keyboard = null;
    setKeyboard = function(keyboard_) {
      keyboard = keyboard_;
    };
    clearScreen = function() {
      video.fill(0);
    };
    setPixel = function(i, j) {
      var address, oldState;
      if (i > HEIGHT) {
        i -= HEIGHT;
      } else if (i < 0) {
        i += HEIGHT;
      }
      if (j > WIDTH) {
        j -= WIDTH;
      } else if (j < 0) {
        j += WIDTH;
      }
      address = (i * WIDTH) + j;
      oldState = video[address];
      video[address] ^= 1;
      return oldState;
    };
    tick = function() {
      var X, Y, height, i, instruction, instructionHi, instructionLo, j, keyState, line, value, _i, _j, _k, _l;
      if (waitingForKey) {
        return;
      }
      instructionHi = memory[programCounter];
      instructionLo = memory[programCounter + 1];
      X = instructionHi & 0x0F;
      Y = instructionLo >> 4;
      instruction = (instructionHi << 8) | instructionLo;
      if (delayTimer > 0) {
        delayTimer--;
      }
      if (soundTimer > 0) {
        soundTimer--;
      }
      programCounter += 2;
      switch (0xF0 & instructionHi) {
        case 0x00:
          switch (instructionLo) {
            case 0xE0:
              clearScreen();
              break;
            case 0xEE:
              stackPointer--;
              programCounter = stack[stackPointer];
          }
          break;
        case 0x10:
          programCounter = instruction & 0x0FFF;
          break;
        case 0x20:
          stack[stackPointer] = programCounter;
          stackPointer++;
          programCounter = instruction & 0x0FFF;
          break;
        case 0x30:
          if (instructionLo === V[X]) {
            programCounter += 2;
          }
          break;
        case 0x40:
          if (instructionLo !== V[X]) {
            programCounter += 2;
          }
          break;
        case 0x50:
          if (V[X] === V[Y]) {
            programCounter += 2;
          }
          break;
        case 0x60:
          V[X] = instructionLo;
          break;
        case 0x70:
          V[X] += instructionLo;
          break;
        case 0x80:
          switch (0x0F & instructionLo) {
            case 0x00:
              V[X] = V[Y];
              break;
            case 0x01:
              V[X] |= V[Y];
              break;
            case 0x02:
              V[X] &= V[Y];
              break;
            case 0x03:
              V[X] ^= V[Y];
              break;
            case 0x04:
              V[X] += V[Y];
              V[0xF] = +(V[X] < V[Y]);
              break;
            case 0x05:
              V[0xF] = +(V[X] > V[Y]);
              V[X] -= V[Y];
              break;
            case 0x06:
              V[0xF] = V[X] & 0x01;
              V[X] >>= 1;
              break;
            case 0x07:
              V[0xF] = +(V[Y] > V[X]);
              V[X] = V[Y] - V[X];
              break;
            case 0x0E:
              V[0xF] = V[X] & 0x80;
              V[X] <<= 1;
          }
          break;
        case 0x90:
          if (V[X] !== V[Y]) {
            programCounter += 2;
          }
          break;
        case 0xA0:
          I = instruction & 0x0FFF;
          break;
        case 0xB0:
          programCounter = (instruction & 0x0FFF) + V[0];
          break;
        case 0xC0:
          V[X] = ((Math.random() * 256) | 0) & instructionLo;
          break;
        case 0xD0:
          V[0xF] = 0;
          height = instructionLo & 0x0F;
          for (i = _i = 0; 0 <= height ? _i < height : _i > height; i = 0 <= height ? ++_i : --_i) {
            line = memory[I + i];
            for (j = _j = 0; _j < 8; j = ++_j) {
              if (line & 0x80) {
                if (setPixel(V[Y] + i, V[X] + j)) {
                  V[0xF] = 1;
                }
              }
              line <<= 1;
            }
          }
          break;
        case 0xE0:
          switch (instructionLo) {
            case 0x9E:
              keyState = keyboard.getState(V[X]);
              if (keyState === 1) {
                programCounter += 2;
              }
              break;
            case 0xA1:
              keyState = keyboard.getState(V[X]);
              if (keyState === 0) {
                programCounter += 2;
              }
          }
          break;
        case 0xF0:
          switch (instructionLo) {
            case 0x07:
              V[X] = delayTimer;
              break;
            case 0x0A:
              waitingForKey = true;
              keyboard.waitForKey(function(key) {
                waitingForKey = false;
                return V[X] = key;
              });
              break;
            case 0x15:
              delayTimer = V[X];
              break;
            case 0x18:
              soundTimer = V[X];
              break;
            case 0x1E:
              I += V[X];
              break;
            case 0x29:
              I = V[X] * 5;
              break;
            case 0x33:
              value = V[X];
              memory[I + 2] = value % 10;
              value = Math.floor(value / 10);
              memory[I + 1] = value % 10;
              value = Math.floor(value / 10);
              memory[I + 0] = value % 10;
              break;
            case 0x55:
              for (i = _k = 0; 0 <= X ? _k <= X : _k >= X; i = 0 <= X ? ++_k : --_k) {
                memory[I + i] = V[i];
              }
              break;
            case 0x65:
              for (i = _l = 0; 0 <= X ? _l <= X : _l >= X; i = 0 <= X ? ++_l : --_l) {
                V[i] = memory[I + i];
              }
          }
          break;
        default:
          console.log('unsupported');
      }
    };
    return {
      tick: tick,
      load: load,
      reset: reset,
      clearScreen: clearScreen,
      getVideo: getVideo,
      getRegisters: getRegisters,
      getProgramCounter: getProgramCounter,
      getStackPointer: getStackPointer,
      getStack: getStack,
      getI: getI,
      setKeyboard: setKeyboard
    };
  };

  window.Chip8 = Chip8;

}).call(this);
